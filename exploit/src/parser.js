const BufferReader = require('buffer-reader');
const C = require('./constants');

const messageParsers = new Map();
messageParsers.set(C.messageType.ALERT, parseAlertMessage);
messageParsers.set(C.messageType.HANDSHAKE, parseHandshakeMessage);
messageParsers.set(C.messageType.HEARTBEAT, parseHeartbeatMessage);

const handshakeContentParsers = new Map();
handshakeContentParsers.set(C.handshakeType.CLIENT_HELLO, parseClientHello);
handshakeContentParsers.set(C.handshakeType.SERVER_HELLO, parseServerHello);
handshakeContentParsers.set(C.handshakeType.SERVER_DONE, parseServerDone);

function parseAlertMessage(buffer) {
    return {
        level: buffer.nextUInt8(),
        description: buffer.nextUInt8(),
    };
}

function parseHandshakeMessage(buffer) {
    const message = {
        type: buffer.nextUInt8(),
        length: parseInt(buffer.nextBuffer(3).toString('hex'), 16),
    };

    const parseHandshakeContent = handshakeContentParsers.get(message.type);

    if(parseHandshakeContent) {
        message.content = parseHandshakeContent(buffer);
    }
    else {
        console.log('WARNING Unknown handshake type: 0x' + message.type.toString(16));
    }

    return message;
}

function parseHeartbeatMessage(buffer) {
    const message = {
        type: buffer.nextUInt8(),
        length: buffer.nextUInt16BE(),
    };

    message.payload = buffer.restAll();

    return message;
}

function parseClientHello(buffer) {
    const content = {
        version: buffer.nextUInt16BE(),
        timestamp: parseTimestamp(buffer),
        random: buffer.nextBuffer(28),
        sessionId: parseSessionId(buffer),
        cipherSuites: parseCipherSuites(buffer),
        compressionMethods: parseCompressionMethods(buffer),
        extensions: parseExtensions(buffer),
    };

    return content;
}

function parseServerHello(buffer) {
    return {
        version: buffer.nextUInt16BE(),
        timestamp: parseTimestamp(buffer),
        random: buffer.nextBuffer(28),
        sessionId: parseSessionId(buffer),
        cipherSuite: buffer.nextUInt16BE(),
        compressionMethod: buffer.nextUInt8(),
    }
}

function parseServerDone() {
    // A server hello handshake message has no content
    return null;
}

function parseTimestamp(buffer) {
    return new Date(buffer.nextUInt32BE() * 1000);
}

function parseSessionId(buffer) {
    const length = buffer.nextUInt8();
    return buffer.nextBuffer(length);
}

function parseCipherSuites(buffer) {
    const length = buffer.nextUInt16BE() / 2;
    const suites = [];

    for(let i = 0; i < length; i++) {
        suites.push(buffer.nextUInt16BE());
    }

    return suites;
}

function parseCompressionMethods(buffer) {
    const length = buffer.nextUInt8();
    const methods = [];

    for (let i = 0; i < length; i++) {
        methods.push(buffer.nextUInt8());
    }

    return methods;
}

function parseExtensions(buffer) {

}

module.exports = function(buf) {
    const buffer = new BufferReader(buf);
    const record = {
        type: buffer.nextUInt8(),
        version: buffer.nextUInt16BE(),
        length: buffer.nextUInt16BE(),
    }

    const parseMessage = messageParsers.get(record.type);

    if(parseMessage) {
        record.message = parseMessage(buffer);
    }
    else {
        console.log('WARNING Unknown message type: 0x' + record.type.toString(16));
    }

    return record;
}