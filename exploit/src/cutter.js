const stream = require('stream');
const log = require('log').get('cutter:transform');
const cacheLog = require('log').get('cutter:cache');

class Cache {
    constructor(length) {
        cacheLog.debug('Creating new Cache');
        
        this.buffer = Buffer.alloc(length);
        this.offset = 0;
        
        cacheLog.debug(this);
    }

    get remaining() {
        const remaining = this.buffer.length - this.offset;
        cacheLog.debug('Bytes to be filled:', remaining);
        return remaining;
    }

    get isFull() {
        const isFull = this.remaining === 0;
        cacheLog.debug('Is full:', isFull);
        return isFull;
    }

    append(chunk) {
        const numBytes = Math.min(this.remaining, chunk.length);
        cacheLog.debug('Appending %i bytes at offset: %i', numBytes, this.offset);
        this.buffer.set(chunk.subarray(0, numBytes), this.offset);
        this.offset += numBytes;
        cacheLog.debug('New offset:', this.offset);
        cacheLog.debug('Remaining bytes in chunk:', chunk.length - numBytes);
        return numBytes;
    }

    clear() {
        cacheLog.debug('Clearing cache');
        this.buffer.fill(0);
        this.offset = 0;
    }
}

module.exports = class PacketCutter extends stream.Transform {
    constructor(headerLength, getLength, options) {
        log.info('Creating new PacketCutter');
        super({ ...options, objectMode: false });
        this.headerLength = headerLength;
        this.getLength = getLength;
        this.header = new Cache(headerLength);
        this.packet = null;
        this.filling = 'header';
        log.debug(this);
    }

    _transform(chunk, encoding, cb) {
        log.debug('Transforming:', chunk);
        const cache = this[this.filling];
        const numBytes = cache.append(chunk);
        const remaining = chunk.length - numBytes;
        log.debug('Wrote %i bytes to <%s> cache; %i bytes remaining in chunk', numBytes, this.filling, remaining);

        if(cache.isFull) {
            log.debug('Cache is full');
            if(this.filling === 'header') {
                const packetLength = this.getLength(this.header.buffer);
                log.debug('Header cache is full. Creating new packet cache of %i bytes.', packetLength);
                this.packet = new Cache(packetLength);
                this.packet.append(this.header.buffer);
                this.filling = 'packet';
                this.header.clear();
            }
            else {
                log.debug('Packet cache is full. Pushing out packet.');
                this.push(this.packet.buffer);
                this.filling = 'header';
            }
        }

        if(remaining) {
            log.debug('%i bytes remaining in chunk. Trandforming again.', remaining);
            this._transform(chunk.subarray(numBytes), encoding, cb);
        }
        else {
            log.debug('Chunk is fully processed.');
            cb();
        }
    }
}