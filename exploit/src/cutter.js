const stream = require('stream');

class Cache {
    constructor(length) {
        this.buffer = Buffer.alloc(length);
        this.offset = 0;
    }

    get remaining() {
        return this.buffer.length - this.offset;
    }

    get isFull() {
        return this.remaining === 0;
    }

    append(chunk) {
        const numBytes = Math.min(this.remaining, chunk.length);
        this.buffer.set(chunk.subarray(0, numBytes), this.offset);
        this.offset += numBytes;
        return numBytes;
    }

    clear() {
        this.buffer.fill(0);
        this.offset = 0;
    }
}

module.exports = class PacketCutter extends stream.Transform {
    constructor(headerLength, getLength, options) {
        super({ ...options, objectMode: false });
        this.headerLength = headerLength;
        this.getLength = getLength;
        this.header = new Cache(headerLength);
        this.packet = null;
        this.filling = 'header';
    }

    _transform(chunk, encoding, cb) {
        const cache = this[this.filling];
        const numBytes = cache.append(chunk);
        const remaining = chunk.length - numBytes;

        if(cache.isFull) {
            if(this.filling === 'header') {
                const packetLength = this.getLength(this.header.buffer);
                this.packet = new Cache(packetLength);
                this.packet.append(this.header.buffer);
                this.filling = 'packet';
                this.header.clear();
            }
            else {
                this.push(this.packet.buffer);
                this.filling = 'header';
            }
        }

        if(remaining) {
            this._transform(chunk.subarray(numBytes), encoding, cb);
        }
        else {
            cb();
        }
    }
}