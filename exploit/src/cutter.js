const stream = require('stream');

class Cache {
    constructor(length) {
        this.buffer = Buffer.alloc(length);
        this.offset = 0;
    }

    get remaining() {
        return this.buffer.length - this.offset;
    }

    get isFull() {
        return this.remaining === 0;
    }

    append(chunk) {
        const numBytes = chunk.copy(this.buffer, this.offset);
        this.offset += numBytes;
        return numBytes;
    }

    clear() {
        this.buffer.fill(0);
        this.offset = 0;
    }
}

module.exports = class PacketCutter extends stream.Transform {
    constructor(headerLength, getLength, options) {
        super({ ...options, decodeString: false });
        this.headerLength = headerLength;
        this.getLength = getLength;
        this.header = new Cache(headerLength);
        this.packet = null;
        this.filling = 'header';
    }

    _transform(chunk) {
        log(chunk)
        const cache = this[this.filling];
        const numBytes = cache.append(chunk);
        const remaining = chunk.length - numBytes;

        log(this.filling);
        log(numBytes);
        log(cache.isFull)
        log(remaining);

        if(cache.isFull) {
            if(this.filling === 'header') {
                log('Header full; creating packet');
                this.packet = new Cache(this.getLength(this.header.buffer));
                this.packet.append(this.header.buffer);
                this.filling = 'packet';
                this.header.clear();
            }
            else {
                log('Packet full; dispatching');
                this.push(this.packet.buffer);
                this.filling = 'header';
            }
        }

        if(remaining) {
            log('Some data remains; running _transform again');
            this._transform(chunk.slice(numBytes));
        }
    }
}

function log(...args) {
    console.log('CUTTER', ...args);
}